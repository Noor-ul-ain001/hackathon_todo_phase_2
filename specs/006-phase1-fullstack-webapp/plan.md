# Implementation Plan: Phase 1 Full-Stack Web Application

**Branch**: `006-phase1-fullstack-webapp` | **Date**: 2025-12-24 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/006-phase1-fullstack-webapp/spec.md`

**Note**: This plan follows the Spec-Kit Plus methodology for full-stack web application development with strict phase-bound enforcement and agentic workflow.

## Summary

Transform the existing Todo console application into a modern, multi-user, full-stack web application with:
- **Frontend**: Next.js 16+ with Better Auth for JWT issuance
- **Backend**: FastAPI with JWT verification and SQLModel ORM
- **Database**: Neon Serverless PostgreSQL with user data isolation
- **Security**: JWT-based authentication on all endpoints, user_id verification
- **Architecture**: Monorepo with frontend/backend separation

**Primary Requirement**: Implement Phase 1 core features (authentication + CRUD) with secure multi-user support and persistent storage.

**Technical Approach**: Build a three-tier architecture (Frontend â†’ REST API â†’ Database) with stateless JWT authentication and strict user data isolation enforced at the backend layer.

## Technical Context

**Language/Version**:
- **Frontend**: TypeScript with Next.js 16+ (App Router)
- **Backend**: Python 3.11+ with FastAPI
- **Database**: PostgreSQL 14+ (Neon Serverless)

**Primary Dependencies**:
- **Frontend**: Next.js 16+, Better Auth, TypeScript, React 18+
- **Backend**: FastAPI, SQLModel, Pydantic, python-jose (JWT), passlib (password hashing), uvicorn
- **Database**: Neon PostgreSQL client, asyncpg or psycopg2

**Storage**: Neon Serverless PostgreSQL with two tables (users managed by Better Auth, tasks with user_id foreign key)

**Testing**: Manual browser-based testing for Phase 1 (automated tests optional for future phases)

**Target Platform**:
- **Frontend**: Modern browsers (Chrome, Firefox, Safari, Edge) on desktop and mobile
- **Backend**: Server/container deployment (Docker, cloud platforms)

**Project Type**: Web application (monorepo) with separate frontend and backend codebases

**Performance Goals**:
- Task list loads in < 2 seconds (up to 100 tasks)
- API responses < 500ms at p95
- Support 100+ concurrent authenticated users

**Constraints**:
- All API endpoints MUST require JWT authentication
- User data MUST be isolated (no cross-user access)
- MUST use monorepo structure
- MUST NOT implement Phase 2/3 features
- Frontend MUST NOT access database directly

**Scale/Scope**:
- Target: Hundreds to thousands of users
- Data: Tasks table with user_id foreign key
- MVP: 6 user stories, 36 functional requirements, 104 implementation tasks

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Core Principles Compliance

âœ… **I. Specification First (NON-NEGOTIABLE)**
- Spec.md complete with 6 user stories and 36 functional requirements
- User approval obtained before planning
- All features traceable to spec

âœ… **II. Phase-Bound Enforcement (NON-NEGOTIABLE)**
- Phase 1 scope: Basic CRUD + Auth only
- Explicitly excludes search, filter, sort, priorities, tags, recurring tasks
- Clear phase boundaries documented

âœ… **III. Agentic Workflow Only (NON-NEGOTIABLE)**
- Workflow: spec â†’ plan â†’ tasks â†’ implement â†’ review
- All code generated by Claude Code agents
- Reusable subagents: spec_writer, planner_agent, task_designer, frontend_implementer, backend_implementer, quality_reviewer

âœ… **IV. Modular Full-Stack Architecture**
- Clear separation: Frontend (Next.js) â†’ API (FastAPI) â†’ Database (PostgreSQL)
- Frontend communicates only via REST API
- Backend enforces JWT and user isolation
- Single responsibility per layer

âœ… **V. Authentication & Security (CRITICAL)**
- JWT-based authentication required on ALL endpoints
- Better Auth issues tokens on frontend
- Backend verifies JWT signature using shared secret (BETTER_AUTH_SECRET)
- User identity extracted from JWT and used for database queries
- User_id in URL must match JWT subject

âœ… **VI. API Contract Stability**
- 6 RESTful endpoints defined with stable contracts
- GET/POST /api/{user_id}/tasks
- GET/PUT/DELETE /api/{user_id}/tasks/{id}
- PATCH /api/{user_id}/tasks/{id}/complete
- Versioned via URL path

âœ… **VII. Data Model Integrity (Phase-Safe)**
- Task entity with Phase 1 fields only: id, user_id, title, description, completed, created_at, updated_at
- User entity managed by Better Auth
- No additional fields without spec amendment

âœ… **VIII. Monorepo Structure**
- Required structure: frontend/, backend/, specs/, .specify/, docker-compose.yml
- Layer-specific CLAUDE.md files (frontend/CLAUDE.md, backend/CLAUDE.md)
- Shared environment configuration

âœ… **IX. Reusable Intelligence**
- Agents: spec_writer, planner_agent, task_designer, frontend_implementer, backend_implementer, quality_reviewer
- Skills: spec_driven_development, full_stack_architecture, jwt_authentication, fastapi_api_design, nextjs_app_router_patterns, user_data_isolation

âœ… **X. Documentation Standards**
- README.md with setup instructions
- CLAUDE.md at root and layer-specific
- Spec, plan, tasks documentation complete

**Constitution Check Result**: âœ… **PASSED** - All principles compliant

## Project Structure

### Documentation (this feature)

```text
specs/006-phase1-fullstack-webapp/
â”œâ”€â”€ plan.md              # This file (/sp.plan command output)
â”œâ”€â”€ spec.md              # Feature specification (/sp.specify command)
â”œâ”€â”€ overview.md          # Project overview and tech stack
â”œâ”€â”€ tasks.md             # Task breakdown (/sp.tasks command)
â”œâ”€â”€ research.md          # Phase 0 research findings
â”œâ”€â”€ data-model.md        # Phase 1 data model
â”œâ”€â”€ quickstart.md        # Phase 1 quickstart guide
â”œâ”€â”€ features/            # Feature-specific specs
â”‚   â”œâ”€â”€ task-crud.md
â”‚   â””â”€â”€ authentication.md
â”œâ”€â”€ api/                 # API contracts
â”‚   â””â”€â”€ rest-endpoints.md
â”œâ”€â”€ database/            # Database schema
â”‚   â””â”€â”€ schema.md
â””â”€â”€ checklists/          # Quality validation
    â””â”€â”€ requirements.md
```

### Source Code (repository root)

```text
C:\Users\user\Desktop\todo\phase1 - Copy\
â”œâ”€â”€ .specify/
â”‚   â”œâ”€â”€ memory/constitution.md
â”‚   â”œâ”€â”€ templates/
â”‚   â””â”€â”€ scripts/
â”œâ”€â”€ specs/               # (see above)
â”œâ”€â”€ history/
â”‚   â”œâ”€â”€ prompts/
â”‚   â””â”€â”€ adr/
â”œâ”€â”€ CLAUDE.md            # Root agent rules
â”œâ”€â”€ README.md            # Project documentation
â”œâ”€â”€ docker-compose.yml   # Local development orchestration
â”œâ”€â”€ .env.example         # Environment variable template
â”œâ”€â”€ .gitignore
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ CLAUDE.md        # Frontend-specific rules
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ next.config.js
â”‚   â”œâ”€â”€ .env.local
â”‚   â”œâ”€â”€ app/             # Next.js App Router
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ page.tsx     # Landing/redirect
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ register/page.tsx
â”‚   â”‚   â”‚   â””â”€â”€ signin/page.tsx
â”‚   â”‚   â””â”€â”€ tasks/
â”‚   â”‚       â””â”€â”€ page.tsx # Protected task dashboard
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ TaskList.tsx
â”‚   â”‚   â”œâ”€â”€ TaskForm.tsx
â”‚   â”‚   â”œâ”€â”€ TaskEditForm.tsx
â”‚   â”‚   â””â”€â”€ ConfirmDialog.tsx
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ auth.ts      # Better Auth configuration
â”‚   â”‚   â””â”€â”€ api-client.ts # API client with JWT attachment
â”‚   â”œâ”€â”€ middleware.ts    # Protected route enforcement
â”‚   â””â”€â”€ public/
â””â”€â”€ backend/
    â”œâ”€â”€ CLAUDE.md        # Backend-specific rules
    â”œâ”€â”€ pyproject.toml   # Python dependencies (UV)
    â”œâ”€â”€ .env
    â”œâ”€â”€ main.py          # FastAPI app entry point
    â””â”€â”€ src/
        â”œâ”€â”€ models/
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ user.py       # User model (Better Auth managed)
        â”‚   â””â”€â”€ task.py       # Task model with user_id FK
        â”œâ”€â”€ api/
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â””â”€â”€ routes/
        â”‚       â”œâ”€â”€ __init__.py
        â”‚       â”œâ”€â”€ auth.py   # Authentication endpoints (if needed)
        â”‚       â””â”€â”€ tasks.py  # Task CRUD endpoints
        â”œâ”€â”€ auth/
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ jwt_utils.py     # JWT decode/verify
        â”‚   â””â”€â”€ dependencies.py  # get_current_user dependency
        â””â”€â”€ database/
            â”œâ”€â”€ __init__.py
            â”œâ”€â”€ connection.py    # Neon PostgreSQL connection
            â”œâ”€â”€ base.py          # SQLModel base config
            â””â”€â”€ init_db.py       # Table creation
```

**Structure Decision**: Web application (monorepo) with Option 2 structure - frontend and backend as separate projects within the monorepo, communicating via REST API with shared environment configuration.

## Complexity Tracking

> **No Constitution Violations Detected** - All architecture decisions align with constitution principles.

| Potential Concern | Justification | Alternative Considered |
|-------------------|---------------|------------------------|
| Monorepo complexity | Required by constitution for coordinated frontend/backend development | Separate repos rejected - harder to maintain shared contracts |
| JWT shared secret | Enables stateless auth, required by spec | Session-based auth rejected - doesn't scale horizontally |
| Better Auth + Custom JWT verification | Better Auth handles frontend, custom backend verification required for FastAPI | Auth0/Clerk rejected - adds external dependency, cost |

---

## Phase 0: Research & Technical Decisions

**Status**: Complete (all decisions resolved during specification phase)

### Research Findings

#### Decision 1: Frontend Framework
- **Chosen**: Next.js 16+ with App Router
- **Rationale**: Modern React framework with SSR/SSG, TypeScript support, excellent developer experience
- **Alternatives Considered**: Vite + React, Remix - rejected for less mature ecosystem and fewer integrations

#### Decision 2: Backend Framework
- **Chosen**: FastAPI
- **Rationale**: Modern Python framework, automatic OpenAPI docs, async support, excellent validation with Pydantic
- **Alternatives Considered**: Django REST Framework (too heavy), Flask (less modern), Express.js (different language)

#### Decision 3: Database
- **Chosen**: Neon Serverless PostgreSQL
- **Rationale**: Managed PostgreSQL, serverless scaling, developer-friendly, PostgreSQL compatibility
- **Alternatives Considered**: Supabase (adds unnecessary features), AWS RDS (requires more ops), SQLite (not production-ready for multi-user)

#### Decision 4: ORM
- **Chosen**: SQLModel
- **Rationale**: Combines SQLAlchemy + Pydantic, type-safe, works seamlessly with FastAPI
- **Alternatives Considered**: Raw SQLAlchemy (more boilerplate), Tortoise ORM (less mature)

#### Decision 5: Authentication Strategy
- **Chosen**: Better Auth (frontend) + Custom JWT verification (backend)
- **Rationale**: Better Auth handles user management and token issuance, custom verification gives control over FastAPI integration
- **Alternatives Considered**: NextAuth.js (similar but less flexible), Auth0 (adds cost and external dependency), custom implementation (too much work)

#### Decision 6: JWT Library
- **Chosen**: python-jose for JWT encoding/decoding
- **Rationale**: Well-maintained, supports multiple algorithms, integrates with FastAPI examples
- **Alternatives Considered**: PyJWT (similar functionality), authlib (heavier)

#### Decision 7: Password Hashing
- **Chosen**: passlib with bcrypt
- **Rationale**: Industry standard, secure, supported by Better Auth
- **Alternatives Considered**: argon2 (newer but less tested), scrypt (slower)

#### Decision 8: Styling Framework
- **Chosen**: Tailwind CSS (decision deferred to implementation - can use vanilla CSS for Phase 1)
- **Rationale**: Utility-first, fast development, responsive by default
- **Alternatives Considered**: CSS Modules, styled-components, MUI

#### Decision 9: Package Manager
- **Chosen**: pnpm (frontend), UV (backend)
- **Rationale**: Faster than npm, disk-efficient, lockfile compatibility
- **Alternatives Considered**: npm (slower), yarn (less modern)

#### Decision 10: Development Environment
- **Chosen**: Docker Compose for local development
- **Rationale**: Consistent environment, easy Neon PostgreSQL proxy or local PostgreSQL
- **Alternatives Considered**: Local services (harder to reproduce), Kubernetes (overkill for dev)

---

## Phase 1: Design & Contracts

### Data Model

See [data-model.md](./data-model.md) for complete entity definitions.

**Key Entities**:
1. **User** (managed by Better Auth)
   - id: string (UUID, primary key)
   - email: string (unique, indexed)
   - password_hash: string
   - created_at: timestamp

2. **Task** (core entity)
   - id: integer (auto-increment, primary key)
   - user_id: string (foreign key â†’ users.id, indexed)
   - title: string (1-200 chars, required)
   - description: text (max 1000 chars, nullable)
   - completed: boolean (default false)
   - created_at: timestamp (auto)
   - updated_at: timestamp (auto-update)

**Relationships**:
- User â†’ Tasks: One-to-Many (cascade delete)
- All task queries MUST filter by user_id

### API Contracts

See [api/rest-endpoints.md](./api/rest-endpoints.md) for complete specifications.

**Base URL**: `/api`

**Authentication**: All requests require `Authorization: Bearer <JWT_TOKEN>`

**Endpoints**:
1. `GET /api/{user_id}/tasks` - List user's tasks
2. `POST /api/{user_id}/tasks` - Create task
3. `GET /api/{user_id}/tasks/{id}` - Get task details
4. `PUT /api/{user_id}/tasks/{id}` - Update task
5. `DELETE /api/{user_id}/tasks/{id}` - Delete task
6. `PATCH /api/{user_id}/tasks/{id}/complete` - Toggle completion

**Security Requirements**:
- JWT verification on every request
- user_id in URL MUST match JWT subject
- Return 403 Forbidden for user_id mismatch
- Return 401 Unauthorized for missing/invalid JWT

### Quickstart Guide

See [quickstart.md](./quickstart.md) for complete setup and testing instructions.

**Quick Test Scenarios**:
1. Registration â†’ JWT issued â†’ redirect to dashboard
2. Sign-in â†’ JWT issued â†’ load tasks
3. Create task â†’ appears in list â†’ persists on refresh
4. Toggle completion â†’ visual update â†’ persists
5. Update task â†’ changes saved â†’ persists
6. Delete task â†’ confirmation â†’ removed permanently
7. Cross-user test â†’ User A cannot access User B's tasks

---

## Implementation Order (Mandatory)

### Step 1: Project & Monorepo Setup
- Validate monorepo structure (frontend/, backend/, specs/, .specify/)
- Create docker-compose.yml for local development
- Create .env.example with DATABASE_URL and BETTER_AUTH_SECRET
- Create layer-specific CLAUDE.md files
- Initialize Next.js in frontend/
- Initialize FastAPI with UV in backend/

### Step 2: Database Layer
- Define Task SQLModel schema in backend/src/models/task.py
- Define User model (Better Auth managed) in backend/src/models/user.py
- Configure Neon PostgreSQL connection in backend/src/database/connection.py
- Create database session dependency in backend/src/database/base.py
- Create table initialization script in backend/src/database/init_db.py
- Ensure user_id foreign key enforcement

### Step 3: Authentication Infrastructure
- Configure Better Auth on frontend in frontend/lib/auth.ts
- Enable JWT plugin with user ID in token payload
- Define shared JWT secret usage (BETTER_AUTH_SECRET environment variable)
- Document token payload expectations (subject = user_id)
- Create registration page in frontend/app/auth/register/page.tsx
- Create sign-in page in frontend/app/auth/signin/page.tsx

### Step 4: Backend Security Middleware
- Implement JWT verification utility in backend/src/auth/jwt_utils.py
- Create get_current_user dependency in backend/src/auth/dependencies.py
- Extract authenticated user from token
- Reject unauthorized requests (401)
- Attach user context to requests (dependency injection)

### Step 5: Backend API Implementation
- Implement GET /api/{user_id}/tasks in backend/src/api/routes/tasks.py
- Implement POST /api/{user_id}/tasks in backend/src/api/routes/tasks.py
- Implement GET /api/{user_id}/tasks/{id} in backend/src/api/routes/tasks.py
- Implement PUT /api/{user_id}/tasks/{id} in backend/src/api/routes/tasks.py
- Implement DELETE /api/{user_id}/tasks/{id} in backend/src/api/routes/tasks.py
- Implement PATCH /api/{user_id}/tasks/{id}/complete in backend/src/api/routes/tasks.py
- Enforce ownership checks on every operation (user_id matching)
- Return standardized JSON responses
- Handle error cases (401, 403, 404, 400, 500)

### Step 6: Frontend API Client
- Create centralized API client in frontend/lib/api-client.ts
- Automatically attach JWT token to Authorization header
- Handle auth-related errors globally (401 â†’ redirect to sign-in)
- Handle network errors with user-friendly messages

### Step 7: Frontend UI Pages
- Build protected /tasks dashboard in frontend/app/tasks/page.tsx
- Create authentication middleware in frontend/middleware.ts
- Implement session restoration in frontend/app/layout.tsx
- Handle loading and empty states

### Step 8: Frontend Task Interactions
- Create TaskList component in frontend/components/TaskList.tsx
- Create TaskForm component (new task) in frontend/components/TaskForm.tsx
- Create TaskEditForm component in frontend/components/TaskEditForm.tsx
- Implement completion toggle UI in TaskList
- Implement delete action with confirmation in frontend/components/ConfirmDialog.tsx

### Step 9: End-to-End Validation
- Verify auth flow: register â†’ sign-in â†’ JWT issued â†’ redirect
- Verify user isolation: User A cannot access User B's tasks
- Verify CRUD operations: create â†’ read â†’ update â†’ delete â†’ complete
- Verify persistence: refresh page â†’ data remains
- Test on multiple browsers (Chrome, Firefox, Safari, Edge)
- Test responsive design (320px to 1920px)

---

## Agent Responsibility Mapping

| Step | Agent | Responsibility |
|------|-------|----------------|
| Specification | spec_writer | Create spec.md with user stories and requirements |
| Architecture Planning | planner_agent | Create plan.md with technical decisions |
| Task Breakdown | task_designer | Create tasks.md with atomic executable tasks |
| Backend Implementation | backend_implementer | Implement FastAPI, SQLModel, JWT verification, API endpoints |
| Frontend Implementation | frontend_implementer | Implement Next.js, Better Auth, React components, API integration |
| Final Validation | quality_reviewer | Verify auth enforcement, user isolation, spec compliance |

---

## Constraints & Guards

### NON-NEGOTIABLE Rules

1. **No endpoint may bypass JWT verification** - All /api/* routes require valid JWT
2. **No frontend request may omit auth headers** - API client MUST attach Authorization header
3. **No cross-user data access allowed** - All queries filtered by authenticated user_id
4. **No feature outside Phase 1 specs allowed** - Search, filter, sort, priorities, tags, recurring tasks, notifications FORBIDDEN
5. **No manual coding** - All code generated by Claude Code agents
6. **No skipping workflow steps** - spec â†’ plan â†’ tasks â†’ implement â†’ review

### Security Guards

- JWT signature verification on every API request
- user_id in URL MUST match JWT subject (403 if mismatch)
- Database queries MUST include WHERE user_id = <authenticated_user>
- Password hashing before storage (never plaintext)
- HTTPS/TLS in production (encrypted data in transit)

### Phase Boundary Guards

- Phase 1 ONLY: Authentication + Basic CRUD
- FORBIDDEN in Phase 1: Search, filter, sort, priority, tags, recurring, notifications, AI
- Automated check: quality_reviewer agent validates no Phase 2/3 features

---

## Exit Criteria (Phase Completion)

Phase 1 is considered complete when ALL of the following are verified:

### Functional Completeness
- âœ… All 6 REST endpoints implemented and tested
- âœ… User registration and sign-in work correctly
- âœ… JWT tokens issued and verified on every request
- âœ… Tasks can be created, viewed, updated, deleted, and toggled
- âœ… All 6 user stories independently testable and passing

### Security Validation
- âœ… Authentication enforced on all /api/* endpoints
- âœ… User data isolation verified (User A cannot access User B's tasks)
- âœ… JWT signature verification working
- âœ… user_id matching enforced (403 on mismatch)
- âœ… Passwords hashed (never stored in plaintext)

### Performance & Usability
- âœ… Task list loads in < 2 seconds (up to 100 tasks)
- âœ… API responses < 500ms at p95
- âœ… System supports 100+ concurrent authenticated users
- âœ… Responsive UI works on desktop and mobile (320px to 1920px)
- âœ… Empty states and loading indicators present

### Quality & Compliance
- âœ… All 36 functional requirements met
- âœ… All 12 success criteria met
- âœ… No Phase 2/3 features implemented (quality_reviewer verification)
- âœ… Constitution principles compliance verified
- âœ… Documentation complete (README, CLAUDE.md, specs)

### Testing
- âœ… Manual browser-based testing complete for all user stories
- âœ… Cross-browser testing (Chrome, Firefox, Safari, Edge)
- âœ… Multiple user accounts tested for data isolation
- âœ… Session restoration tested (close browser â†’ reopen â†’ still signed in)

### Deployment Readiness
- âœ… Environment variables documented (.env.example)
- âœ… Docker Compose configuration tested
- âœ… Setup instructions in README.md
- âœ… Deployment guide created

---

## Risk Analysis & Mitigation

### Top 3 Risks

1. **Risk**: Better Auth + Custom JWT verification integration complexity
   - **Mitigation**: Use python-jose library, follow FastAPI JWT examples, document token payload format
   - **Blast Radius**: Authentication broken â†’ no users can sign in
   - **Kill Switch**: Fallback to basic email/password without Better Auth if integration fails

2. **Risk**: User data leakage due to missing user_id filtering
   - **Mitigation**: Enforce user_id filtering in all database queries, add quality_reviewer validation step
   - **Blast Radius**: Security breach â†’ users can access others' data
   - **Kill Switch**: Disable endpoints and audit all queries if leak detected

3. **Risk**: Neon PostgreSQL connection issues
   - **Mitigation**: Use connection pooling, implement retry logic, test with Docker Compose locally
   - **Blast Radius**: Database unavailable â†’ app unusable
   - **Kill Switch**: Return 503 Service Unavailable, display maintenance message

---

## Architectural Decision Records (ADRs)

**Significant Decisions Requiring ADRs**:

1. **Full-Stack Technology Stack** (Next.js + FastAPI + Neon PostgreSQL)
   - Impact: Long-term technology commitment
   - Alternatives: MERN, Django+React, Ruby on Rails
   - Scope: Affects all layers of application

2. **JWT-Based Stateless Authentication**
   - Impact: Scalability and session management approach
   - Alternatives: Session-based auth with cookies, OAuth providers
   - Scope: Security architecture and horizontal scaling

3. **Monorepo Structure with Layer Separation**
   - Impact: Code organization and deployment strategy
   - Alternatives: Separate repositories, monolithic structure
   - Scope: Development workflow and CI/CD

ðŸ“‹ **Architectural decision detected**: Full-stack technology stack selection (Next.js + FastAPI + Neon PostgreSQL) with JWT authentication architecture.

Document reasoning and tradeoffs? Run `/sp.adr full-stack-technology-stack-and-auth`

---

**Plan Version**: 1.0.0 | **Created**: 2025-12-24 | **Status**: Complete
